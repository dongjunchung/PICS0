{
    "collab_server" : "",
    "contents" : "#' @title Gene selection using SPLS model\n#'\n#' @description Sparse Partial Least Square (SPLS) step for gene selection and dimension reduction.By applying SPLS to each pathway, we achieve the goal of gene selection and dimension reduction at the same time.\n#'\n#' @param object output list of prefilter step\n#' @param fold The number of folds to use to perform the cross-validation process.\n#' @param K the maximum number of hidden features in spls.\n#' @param etas Thresholding parameter. eta should be between 0 and 1.\n#' @param seed random seed that was set,  default = 123.\n#'\n#' @import stats foreach plsRcox survival\n#' @export\n#' @docType methods\n#' @rdname selectGene-methods\n#' @aliases selectGene\n#' @aliases selectGene,Prefiltered-method\n#'\n#' @examples\n#' data(TCGA)\n#' train.list=prefilter( data=TCGA$geneexpr, time=TCGA$t, status=TCGA$d, plist=TCGA$pathList )\n#' gene.results=selectGene( object=train.list, fold=5, K=5, etas=c(0.1,0.9),seed=123)\n\nsetMethod(\n  f=\"selectGene\",\n  signature=\"Prefiltered\",\n  definition=function( object, fold=5, K=5, etas=seq(0.1,0.9,0.1), seed=123 ) {\n\n    time=object@inputdata$time\n    status=object@inputdata$status\n    data=object@xlist\n    pathways=object@inputdata$pathway\n\n    set.seed(seed)\n    n=length(time)\n    cvfolds <- split(sample(n), rep(1:fold, length=n))\n    dimx=unlist( lapply(data,function(x){ncol(as.matrix(x))}) )\n\n    k.opt=eta.opt=NULL\n    score=genes=beta=spls.beta=w=list()\n\n    for(j in 1:length(pathways)){\n      xx=as.matrix( data[[j]],nrow=n,ncol=dimx[j] )\n      kmax=min( K, ncol(xx) )\n\n      if(kmax>1){\n        aucs <- foreach(i=1:length(etas),.combine='rbind') %do% {\n          cvi=cv.coxsplsDR( list(x=xx,time=time,status=status),\n            givefold=cvfolds, nt=kmax, nfold=fold, eta=etas[i],\n            plot.it=F, se=T, sclaleY=F )\n\n          cbind( cvi$cv.error10[-1],cvi$cv.se10[-1]\t)\n        }\n\n        h=which.max(aucs[,1])\n        se1=aucs[h,1]-aucs[h,2]\n\n        ###find aucs within 1se of the maximum\n        mat=cbind( aucs, rep(1:kmax,length(etas)),\n                   rep(etas,each=kmax) )[aucs[,1]>se1,]\n\n        tmp=aucs[,1][aucs[,1]>se1]\n\n        if(length(tmp)>1){\n          ##choose the most parsimonious model in terms of genes\n          ##always choose the smallest k among those with largest eta\n          q=which.max(mat[,4])\n          k.opt[j] <- mat[q,3]\n          eta.opt[j] <- mat[q,4]\n        }\n\n        if(length(tmp)==1){\n          k.opt[j]=mat[3]\n          eta.opt[j]=mat[4]\n        }\n\n        cox=coxph(Surv(time, status) ~ 1)\n        devres=residuals(cox,type=\"deviance\")\n\n        spls.mod=spls.cox (x=xx, y=devres, K=k.opt[j], eta=eta.opt[j],\n                           kappa=0.5, select=\"pls2\", scale.x=T, scale.y=F, trace=F)\n\n        score[[j]]= data.frame(spls.mod$plsmod$variates$X)\n        spls.beta[[j]]=data.frame( colnames(xx),spls.mod$betahat )\n        rownames(spls.beta[[j]])=NULL\n\n        ##objects saved for prediction\n        xA=spls.mod$x[,spls.mod$A]\n        genes[[j]]=colnames(xx)[spls.mod$A]\n        w[[j]]=spls.mod$pred$w\n\n      }else{\n\n        score[[j]]=xx\n        genes[[j]]=names(xx)\n        spls.beta[[j]]=NA\n        k.opt[j]=1\n        eta.opt[j]=w[[j]]=NA\n      }\n    }\n\n    names(genes)=pathways\n    names(spls.beta)=pathways\n\n    new( \"FitGene\",\n      score=score,\n      geneSelected=genes,\n      fit = list( coef=spls.beta, direction=w ),\n      dataPrefiltered=data,\n      inputdata = object@inputdata\n    )\n  }\n)\n",
    "created" : 1488241283474.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "547911939",
    "id" : "B3EFA6D9",
    "lastKnownWriteTime" : 1488241360,
    "last_content_update" : 1488241360342,
    "path" : "C:/Users/sunze/Desktop/package_0209/package0227/PICS/R/selectGene.R",
    "project_path" : "R/selectGene.R",
    "properties" : {
    },
    "relative_order" : 7,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}